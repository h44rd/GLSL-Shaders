<head>
    <link rel="stylesheet" href="index.css">
</head>
<div onmousemove="updateMouse(event)" id="canvasHolder">
    <canvas id="canvas"></canvas>  
</div>
<div id="information">
    <p id="demo"></p>
    <button onclick="seeNextImage()">See Next Image</button>
    <button onclick="toggleVectorField()">Toggle Vector Field</button>
    <p id="imageInformation"></p>
    Bright image url : <input type="text" id="bright_url"><br>
    Dark image url : <input type="text" id="dark_url"><br>
    Normal map url : <input type="text" id="normal_map_url"><br>
    <button onclick="urlInputByUser()">Submit URLs</button>
    <br>
    <p>Fresnel Effect: </p>
    <input type="range" min="1" max="50" value="25" oninput="cartoonEffect()" id="cartoonSlider">
    
    <p>Index of Refraction: </p>
    <input type="range" min="0" max="200" value="50" oninput="changeIOR()" id="iorSlider">
    <p>The Fresnel Function: </p>
    <img src="images/function.png">
</div>
<!-- vertex shader -->
<script  id="2d-vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
</script>
<!-- fragment shader -->
<script  id="2d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// our texture
uniform sampler2D u_bright;
uniform sampler2D u_dark;
uniform sampler2D u_normal_map;

uniform int u_ifUseVectorField;
uniform float u_interpolateDistance;
uniform float u_index_of_refraction;


uniform vec2 u_mouse;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
    vec4 normal = texture2D(u_normal_map, v_texCoord);
    // vec4 bright = texture2D(u_bright, v_texCoord);
    // vec4 dark = texture2D(u_dark, v_texCoord);

    if(length(normal) < 0.005) {
        normal = vec4(0.0);
    }
    vec4 bright = vec4(1.0, 1.0, 1.0, 1.0);
    vec4 dark = vec4(0.0, 0.0, 0.0, 1.0);

    float lightHeight = 1.0;

    // dark = dark / 2.0;

    // normal = pow(normal, vec4(2.0));

    //Directional Light
    //The light direction is from the mouse position to orgin.
    vec3 lightDirection = -1.0 * normalize(vec3(0.0, 0.0, 0.0) - vec3(u_mouse.x, u_mouse.y, lightHeight));

    vec4 correctedNormals = normal;
    correctedNormals.x = 2.0 * correctedNormals.x - 1.0;
    correctedNormals.y = 2.0 * correctedNormals.y - 1.0;
    // correctedNormals.z = correctedNormals.z * correctedNormals.z;

    float scaleFactor = 25.0;

    if(u_ifUseVectorField > 5) {
        correctedNormals.x = sin(v_texCoord.x*scaleFactor) + 0.5;
        correctedNormals.y = sin(v_texCoord.y*scaleFactor) + 0.5;
        correctedNormals.z = sin(v_texCoord.x*scaleFactor) + sin(v_texCoord.y*scaleFactor);
    }

    
    vec3 normalDirection = normalize(vec3(correctedNormals.x, correctedNormals.y, correctedNormals.z));

    // ********************************************************
    // Diffuse Shading
    float intensity_diffuse = max(0.0, dot(normalDirection, lightDirection));
    
    float edge1 = 0.5 - u_interpolateDistance/2.0;
    float edge2 = 0.5 + u_interpolateDistance/2.0; 

    //intensity_diffuse = pow(intensity_diffuse, 3.0);

    intensity_diffuse = smoothstep(edge1, edge2, intensity_diffuse);
    //*********************************************************


    //*********************************************************
    // Specular Shading
    vec3 eye = -1.0 * normalize(vec3(v_texCoord.x, v_texCoord.y, 0) - vec3(u_mouse.x, u_mouse.y, lightHeight));

    vec3 reflection = -1.0 * lightDirection + 2.0 * dot(normalDirection, lightDirection) * normalDirection;
    
    reflection = normalize(reflection);
    
    float intensity_specular = max(0.0, dot(eye, reflection));
    
    intensity_specular = pow(intensity_specular, 3.0);
    intensity_specular = smoothstep(edge1, edge2, intensity_specular);
    //*********************************************************

    //*********************************************************
    //Border
    vec3 downVector = vec3(0.0, 0.0, 1.0);

    float intensity_border = max(0.0, 1.0 - dot(downVector, normalDirection));

    intensity_border = smoothstep(0.7, 0.9, intensity_border);
    //*********************************************************


    //*********************************************************
    //Refraction
    float alpha = log2(u_index_of_refraction);

    vec3 refracted;
    vec3 s;

    if(alpha > 0.0) {
        refracted = alpha * (-1.0 * eye) + (1.0 - alpha) * (-1.0 * normalDirection);
    } else {
        alpha = 1.0 + alpha;
        s = normalize(-1.0 * eye + dot(eye, normalDirection) * normalDirection);
        refracted = alpha * (-1.0 * eye) + (1.0 - alpha) * s;
    }

    refracted = normalize(refracted);

    float env_refrac_dist = 0.2; // Distance of the env image behind (Refraction)

    refracted = env_refrac_dist * (refracted / (refracted.z));

    vec2 refracted_pix_coords = refracted.xy + v_texCoord.xy;

    vec4 refracted_pixel = texture2D(u_bright, refracted_pix_coords);
    
    //*********************************************************

    //*********************************************************
    //Reflection
    float env_reflec_dist = 0.1;

    vec3 reflection_eye = -1.0 * eye + 2.0 * dot(normalDirection, eye) * normalDirection;

    reflection_eye = normalize(reflection_eye);

    vec2 reflected_coords = env_reflec_dist * (reflection_eye.xy / reflection.z);

    reflected_coords = reflected_coords + v_texCoord.xy;

    vec4 reflected_pixel = texture2D(u_dark, reflected_coords);
    //vec4 reflected_pixel = vec4(1.0);    
    //*********************************************************

    //*********************************************************
    // Fresnel
    float cos_eye_normal = dot(eye, normalDirection);
    float sin_eye_normal = sqrt(1.0 - pow(cos_eye_normal, 2.0));

    float refl_refr_ratio;

    float partition_fresnal = u_interpolateDistance/2.0;

    if(sin_eye_normal < partition_fresnal) {
        refl_refr_ratio = (1.0/2.0) * (1.0 - smoothstep(0.1, 0.9, (sin_eye_normal) * (1.0/partition_fresnal))); // Scaling the smoothstep and transforming the sin_eye_normal accordingly
    } else {  //if(sin_eye_normal < 2.0 * partition_fresnal) {
        refl_refr_ratio = smoothstep(0.1, 0.9, (sin_eye_normal - partition_fresnal) * (1.0/partition_fresnal));
    }

    //*********************************************************
    
    vec4 diffuse = intensity_diffuse * bright + (1.0 - intensity_diffuse) * dark;

    vec4 specular = intensity_specular * (bright + diffuse) + (1.0 - intensity_specular) * diffuse;

    vec4 border = intensity_border * dark + (1.0 - intensity_border) * specular;
    
    //gl_FragColor = 0.5 * refracted_pixel + 0.5 * reflected_pixel;

    gl_FragColor = 0.5 * refracted_pixel + 0.5 * reflected_pixel;
    
    if(length(normal.xyz) > 0.005) {
        gl_FragColor =  (refl_refr_ratio) * refracted_pixel + (1.0 - refl_refr_ratio) * reflected_pixel;
    } else {
        gl_FragColor = texture2D(u_bright, v_texCoord);
    }
    //gl_FragColor = 0.45 * refracted_pixel + 0.45 * reflected_pixel + 0.1 * border;
    //gl_FragColor = 0.45 * refracted_pixel + 0.45 * reflected_pixel + 0.1 * border;
    //testing
    //gl_FragColor = texture2D(u_bright, v_texCoord * 3.0);
    //gl_FragColor = vec4(1.0, v_texCoord.y, v_texCoord.x, 1.0);
}
</script><!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="js/main.js"></script>